{"mappings":"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","sources":["src/bump-kaboom.ts","src/bump.ts/index.ts","src/bump.ts/helpers/generic/assertIsPositiveNumber.ts","src/bump.ts/rect.ts","src/bump.ts/constants.ts","src/bump.ts/helpers/generic/nearest.ts","src/bump.ts/grid.ts","src/bump.ts/helpers/generic/assertIsRect.ts","src/bump.ts/helpers/generic/assertType.ts","src/bump.ts/helpers/world/responses.ts","src/bump.ts/helpers/world/sortByTiAndDistance.ts"],"sourcesContent":["import { KaboomCtx, GameObj, Tag, Vec2, Origin } from \"kaboom\"\nimport Bump from './bump.ts/index'\nimport { IRect, ICoords } from './bump.ts/index.js'\n\nexport interface BumpCollision {\n  other: any | null | undefined;\n  item: string | null | undefined;\n  otherObj: Object;\n  itemObj: Object;\n  type?: 'touch' | 'cross' | 'slide' | 'bounce' | string;\n  overlaps: boolean;\n  ti: number;\n  move: ICoords;\n  normal: ICoords;\n  touch: ICoords;\n  itemRect: IRect;\n  otherRect: IRect;\n  slide?: ICoords;\n  bounce?: ICoords;\n}\n\n// turn \"a collides with b on the right side\" to\n// \"b collides with a on the left side\"\n// 'touch', 'slide' and 'bounce' are incorrect,\n// but in this case 'other' should never move, so they\n// should never be used \nfunction invertCollision(c: BumpCollision): BumpCollision {\n  return {\n    other: c.item,\n    item: c.other,\n    otherObj: c.itemObj,\n    itemObj: c.otherObj,\n    type: c.type,\n    overlaps: c.overlaps,\n    ti: c.ti,\n    move: {x: 0, y: 0},\n    normal: {x: -c.normal.x, y:-c.normal.y},\n    touch: c.touch,\n    itemRect: c.otherRect,\n    otherRect: c.itemRect,\n    slide: c.slide,\n    bounce: c.bounce\n  }\n}\n\n// convert origin string to a vec2 offset\nfunction originPt(orig: Origin | Vec2): Vec2 {\n\tswitch (orig) {\n\t\tcase \"topleft\": return vec2(-1, -1);\n\t\tcase \"top\": return vec2(0, -1);\n\t\tcase \"topright\": return vec2(1, -1);\n\t\tcase \"left\": return vec2(-1, 0);\n\t\tcase \"center\": return vec2(0, 0);\n\t\tcase \"right\": return vec2(1, 0);\n\t\tcase \"botleft\": return vec2(-1, 1);\n\t\tcase \"bot\": return vec2(0, 1);\n\t\tcase \"botright\": return vec2(1, 1);\n\t\tdefault: return orig;\n\t}\n}\n\n\nexport default (k: KaboomCtx) => {\n\n  // only one global collision world now \n  const world = Bump.newWorld(50)\n\n  function barea(): any {\n\n    // entry where key=\"wall\", value=\"slide\" means when colliding with\n    // an object with a tag \"wall\" the collision response should be \"slide\"\n    const filterCollection = {} as Record<string, string>\n\n    let bfilter = (_: string, other: string) => {\n\n      for (const [key, value] of Object.entries(filterCollection)) {\n        const otherObj = world.getItemByIndex(other)\n        if (!otherObj) { continue }\n        // @ts-ignore\n        if (otherObj.is(key)) {\n          return value\n        }\n      }\n      return undefined\n\n    }\n\n    return {\n  \n      id: \"barea\",\n      require: [\"pos\", \"area\"],\n\n      barea: {\n        w: 0,\n        h: 0,\n        offset: vec2(0)\n      },\n\n      load() {\n        let w = this.area.width ?? this.width;\n        let h = this.area.height ?? this.height;\n\n        if (w == null || h == null) {\n            throw new Error(\"failed to get area dimension\");\n        }\n\n        const scale = vec2(this.scale ?? 1);\n\n        w *= scale.x;\n        h *= scale.y;\n        this.barea.w = w\n        this.barea.h = h\n        const orig = originPt(this.origin || \"topleft\");\n        const bareaOffset = orig.add(1, 1).scale(0.5).scale(w, h)\n        const pos = (this.pos ?? vec2(0))\n            .sub(bareaOffset);\n        this.barea.offset = bareaOffset\n\n        world.add(this, pos.x, pos.y, w, h)\n      },\n\n      bmoveTo(dest: Vec2) {\n        // move within the Bump world, result is the final coordinates\n        // after all the collidions\n        // can safely teleport (moveTo) to them afterwards\n\n        // apply offset\n        const pos = dest.sub(this.barea.offset);\n\n        const { x, y, collisions } = world.move(this, pos.x, pos.y, bfilter)\n\n        // reverse apply offset\n        const goal = vec2(x, y).add(this.barea.offset);\n        this.moveTo(goal.x, goal.y)\n        \n        for (const col of collisions) {\n            this.trigger(\"bumpcollide\", col.otherObj, col);\n            // @ts-ignore\n            col.otherObj.trigger(\"bumpcollide\", this, invertCollision(col));\n        }\n      },\n\n      bmove(...args: any[]) {\n        if (typeof args[0] === \"number\" && typeof args[1] === \"number\") {\n          return this.bmove(vec2(args[0], args[1]));\n        }\n\n        this.bmoveTo(k.vec2(this.pos.x + args[0].x*dt(), this.pos.y + args[0].y*dt()))\n      },\n  \n      addBumpCollision(tag: Tag, response: string) {\n        filterCollection[tag] = response\n      },\n\n      addCollisionResponse(tag: Tag, f: (o: GameObj, col?: BumpCollision) => void ) {\n        return this.on(\"bumpcollide\", (obj: GameObj, col: BumpCollision) => {\n          obj.is(tag) && f(obj, col)\n        });\n      },\n    };\n  }\n  \n    return {\n      barea\n    }\n  }\n","import assertIsPositiveNumber from './helpers/generic/assertIsPositiveNumber';\nimport {\n  rect_containsPoint,\n  rect_detectCollision,\n  rect_getDiff,\n  rect_getNearestCorner,\n  rect_getSegmentIntersectionIndices,\n  rect_getSquareDistance,\n  rect_isIntersecting,\n} from './rect';\nimport {\n  grid_toCell,\n  grid_toCellRect,\n  grid_toWorld,\n  grid_traverse,\n} from './grid';\nimport assertIsRect from './helpers/generic/assertIsRect';\nimport {\n  bounce,\n  cross,\n  Response,\n  slide,\n  touch,\n} from './helpers/world/responses';\nimport sortByTiAndDistance from './helpers/world/sortByTiAndDistance';\n\nfunction defaultFilter(): string {\n  return 'slide';\n}\n\ninterface IItemInfo {\n  item: string;\n  ti1: number;\n  ti2: number;\n  weight: number;\n}\n\nexport interface IRect {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\nexport interface ICoords {\n  x: number;\n  y: number;\n}\n\nexport interface Collision {\n  other: any | null | undefined;\n  item: string | null | undefined;\n  otherObj: Object;\n  itemObj: Object;\n  type?: 'touch' | 'cross' | 'slide' | 'bounce' | string;\n  overlaps: boolean;\n  ti: number;\n  move: ICoords;\n  normal: ICoords;\n  touch: ICoords;\n  itemRect: IRect;\n  otherRect: IRect;\n  slide?: ICoords;\n  bounce?: ICoords;\n}\n\nexport type Cell = {\n  ID: string;\n  x: number;\n  y: number;\n  items: { [itemID: string]: boolean };\n};\n\nfunction sortByWeight(a: IItemInfo, b: IItemInfo): number {\n  return a.weight - b.weight;\n}\n\nfunction getCellsTouchedBySegment(\n  self: World,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): Cell[] {\n  const cells: Cell[] = [];\n  const visited: { [itemID: string]: boolean } = {};\n\n  grid_traverse(self.cellSize, x1, y1, x2, y2, function(\n    cx: number,\n    cy: number\n  ) {\n    let row: Cell[] = self.rows[cy];\n\n    if (!row) return;\n\n    let cell = row[cx];\n\n    if (!cell || visited[cell.ID]) return;\n\n    visited[cell.ID] = true;\n\n    cells.push(cell);\n  });\n\n  return cells;\n}\n\nfunction getInfoAboutItemsTouchedBySegment(\n  self: World,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  filter?: (other?: string) => boolean\n): { item: string; ti1: number; ti2: number; weight: number | null }[] {\n  let cells = getCellsTouchedBySegment(self, x1, y1, x2, y2);\n  let rect, l, t, w, h, ti1, ti2;\n\n  let visited: { [itemID: string]: boolean } = {};\n  let itemInfo: IItemInfo[] = [];\n\n  for (const cell of cells) {\n    if (cell?.items)\n      for (const itemID of Object.keys(cell.items)) {\n        if (!visited[itemID]) {\n          visited[itemID] = true;\n\n          if (!filter || filter(itemID)) {\n            // rect = self['rectsMap'].get(item)\n            rect = self['rects'][itemID];\n            l = rect.x;\n            t = rect.y;\n            w = rect.w;\n            h = rect.h;\n\n            const arr1 = rect_getSegmentIntersectionIndices(\n              l,\n              t,\n              w,\n              h,\n              x1,\n              y1,\n              x2,\n              y2,\n              0,\n              1\n            );\n\n            ti1 = arr1![0];\n            ti2 = arr1![1];\n\n            if (\n              !isNaN(ti1 as number) &&\n              ((0 < ti1! && ti1! < 1) || (0 < ti2! && ti2! < 1))\n            ) {\n              // -- the sorting is according to the t of an infinite line, not the segment\n              const [tii0, tii1] = rect_getSegmentIntersectionIndices(\n                l,\n                t,\n                w,\n                h,\n                x1,\n                y1,\n                x2,\n                y2,\n                -Number.MAX_SAFE_INTEGER,\n                Number.MAX_SAFE_INTEGER\n              );\n\n              itemInfo.push({\n                item: itemID,\n                ti1: ti1!,\n                ti2: ti2!,\n                weight: Math.min(tii0 || 0, tii1 || 0),\n              });\n            }\n          }\n        }\n      }\n  }\n\n  return itemInfo.sort(sortByWeight);\n}\n\nexport class World {\n  responses: { [responseID: string]: Response } = {};\n  cellSize: number = 0;\n  rows: Cell[][];\n  rectsMap: WeakMap<Object, string>;\n  reverseIdMap: Map<string, Object>;\n  rects: { [itemID: string]: IRect };\n  nonEmptyCells: { [cellID: string]: boolean };\n  currentIndex: number = 0;\n\n  constructor(input: {\n    cellSize: number;\n    rects: {};\n    rows: [];\n    nonEmptyCells: {};\n    responses: {};\n  }) {\n    this.cellSize = input.cellSize;\n    this.rects = input.rects;\n    this.rows = input.rows;\n    this.nonEmptyCells = input.nonEmptyCells;\n    this.responses = input.responses;\n    this.rectsMap = new WeakMap();\n    this.reverseIdMap = new Map();\n    this.currentIndex = 0;\n  }\n\n  addResponse(\n    name: 'bounce' | 'slide' | 'cross' | 'touch',\n    response: Response\n  ): void {\n    this.responses[name] = response;\n  }\n\n  getResponseByName(name: string): any {\n    const response = this.responses[name];\n\n    if (!response)\n      throw new Error(`Unknown collision type: ${name} (${typeof name})`);\n\n    return response;\n  }\n\n  // TODO: make the function take objects (maybe, if kept public)\n  project(\n    itemID: string | null,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    goalX?: number,\n    goalY?: number,\n    filter?: (...args: any[]) => string\n  ): Collision[] {\n    assertIsRect(x, y, w, h);\n\n    const _goalX = isNaN(goalX as number) ? x : goalX!;\n    const _goalY = isNaN(goalY as number) ? y : goalY!;\n\n    const _filter = filter || defaultFilter;\n\n    let collisions: Collision[] = [];\n\n    let visited: { [itemID: string]: boolean } = {};\n\n    if (itemID) visited[itemID] = true;\n\n    // This could probably be done with less cells using a polygon raster over the cells instead of a\n    // bounding rect of the whole movement.Conditional to building a queryPolygon method\n    let tl: number = Math.min(_goalX, x);\n    let tt: number = Math.min(_goalY, y);\n\n    let tr: number = Math.max(_goalX + w, x + w);\n    let tb: number = Math.max(_goalY + h, y + h);\n\n    let tw: number = tr - tl;\n    let th: number = tb - tt;\n\n    let [cl, ct, cw, ch] = grid_toCellRect(this.cellSize, tl, tt, tw, th);\n\n    let dictItemsInCellRect: {\n      [itemID: string]: boolean;\n    } = this.getDictItemsInCellRect(cl, ct, cw, ch);\n\n    for (const other of Object.keys(dictItemsInCellRect)) {\n      if (!visited[other]) {\n        visited[other] = true;\n\n        const responseName: string = _filter(itemID, other);\n\n        if (\n          responseName &&\n          /* why do I have to do this extra check? */ this._hasItem(other)\n        ) {\n          let otherRect = this._getRect(other);\n\n          let collision: Partial<Collision> | undefined = rect_detectCollision(\n            x,\n            y,\n            w,\n            h,\n            otherRect.x,\n            otherRect.y,\n            otherRect.w,\n            otherRect.h,\n            _goalX,\n            _goalY\n          );\n\n          if (collision) {\n            collision.other = other;\n            collision.otherObj = this.reverseIdMap.get(other);\n            collision.item = itemID;\n            // @ts-ignore\n            collision.itemObj = this.reverseIdMap.get(itemID);\n            collision.type = responseName;\n\n            collisions.push(collision as Collision);\n          }\n        }\n      }\n    }\n\n    return collisions.sort(sortByTiAndDistance);\n  }\n\n  countCells(): number {\n    let count = 0;\n\n    for (const row of this.rows.filter(row => !!row))\n      for (const _col of row) if (!!_col) count++;\n\n    return count;\n  }\n\n  // public\n  hasItem(item: Object): boolean {\n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      return false\n    }\n    \n    // return this.rectsMap.has(item);\n    return !!this.rects[itemID];\n  }\n\n  _hasItem(item: string): boolean {\n    return !!this.rects[item];\n  }\n\n\n  getItems(): IRect[] {\n    return Object.keys(this.rects).map(rectID => this.rects[rectID]);\n  }\n\n  countItems(): number {\n    return Object.keys(this.rects).length;\n  }\n\n  private addItemToCell(itemID: string, cx: number, cy: number): void {\n    this.rows[cy] = this.rows[cy] || [];\n\n    const row = this.rows[cy];\n\n    // Initialize a cell if no cell is present at this point\n    if (!row[cx])\n      row[cx] = {\n        ID: `Cell_${Math.ceil(Math.random() * Date.now()).toString(36)}`,\n        x: cx,\n        y: cy,\n        items: {},\n      };\n\n    const cell = row[cx];\n\n    this.nonEmptyCells[cell.ID] = true;\n\n    if (!cell.items[itemID]) cell.items[itemID] = true;\n  }\n\n  // public\n  getRect(item: Object): IRect {\n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      throw new Error(\n        `Item \"${itemID}\" must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.`\n      );\n    }\n    return this._getRect(itemID);\n  }\n\n  _getRect(itemID: string): IRect {\n    let rect = this.rects[itemID];\n\n    if (!rect)\n      throw new Error(\n        `Item \"${itemID}\" must be added to the world before getting its rect. Use world:add(item, x,y,w,h) to add it first.`\n      );\n\n    return {\n      x: rect.x,\n      y: rect.y,\n      w: rect.w,\n      h: rect.h,\n    };\n  }\n  \n  // public\n  getDictItemsInCellRect(\n    cl: number,\n    ct: number,\n    cw: number,\n    ch: number\n  ): { [itemID: string]: boolean } {\n    const items_dict: { [itemID: string]: boolean } = {};\n\n    for (let cy = ct; cy <= ct + ch - 1; cy++) {\n      let row = this.rows[cy];\n\n      if (row) {\n        for (let cx = cl; cx <= cl + cw - 1; cx++) {\n          let cell = row[cx];\n\n          if (cell?.items && Object.keys(cell.items)?.length > 0)\n            // no cell.itemCount > 1 because tunneling\n            for (const itemID of Object.keys(cell.items))\n              items_dict[itemID] = true;\n        }\n      }\n    }\n\n    return items_dict;\n  }\n\n  private removeItemFromCell(itemID: string, cx: number, cy: number): boolean {\n    let row = this.rows[cy];\n\n    if (!row?.[cx]?.['items']?.[itemID]) return false;\n\n    let cell = row[cx];\n\n    delete cell.items[itemID];\n\n    if (Object.keys(cell.items)?.length === 0)\n      delete this.nonEmptyCells[cell.ID];\n\n    return true;\n  }\n\n  // public\n  toWorld(cx: number, cy: number): [number, number] {\n    return grid_toWorld(this.cellSize, cx, cy);\n  }\n\n  // public\n  toCell(x: number, y: number): [number, number] {\n    return grid_toCell(this.cellSize, x, y);\n  }\n\n  // public\n  queryRect(\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    filter?: (other?: string) => boolean\n  ): string[] {\n    assertIsRect(x, y, w, h);\n\n    const [cl, ct, cw, ch] = grid_toCellRect(this.cellSize, x, y, w, h);\n    const dictItemsInCellRect = this.getDictItemsInCellRect(cl, ct, cw, ch);\n\n    const items: string[] = [];\n\n    for (const itemID of Object.keys(dictItemsInCellRect))\n      if (\n        (!filter || filter(itemID)) &&\n        rect_isIntersecting(\n          x,\n          y,\n          w,\n          h,\n          this.rects[itemID].x,\n          this.rects[itemID].y,\n          this.rects[itemID].w,\n          this.rects[itemID].h\n        )\n      )\n        items.push(itemID);\n\n    return items;\n  }\n\n  // public\n  queryPoint(\n    x: number,\n    y: number,\n    filter?: (other?: string) => boolean\n  ): string[] {\n    const [cx, cy] = this.toCell(x, y);\n    const dictItemsInCellRect = this.getDictItemsInCellRect(cx, cy, 1, 1);\n\n    const items: string[] = [];\n\n    for (const itemID of Object.keys(dictItemsInCellRect))\n      if (\n        (!filter || filter(itemID)) &&\n        rect_containsPoint(\n          this.rects[itemID].x,\n          this.rects[itemID].y,\n          this.rects[itemID].w,\n          this.rects[itemID].h,\n          x,\n          y\n        )\n      )\n        items.push(itemID);\n\n    return items;\n  }\n\n  // public\n  querySegment(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    filter?: (other?: string) => boolean\n  ): string[] {\n    const itemsInfo = getInfoAboutItemsTouchedBySegment(\n      this,\n      x1,\n      y1,\n      x2,\n      y2,\n      filter\n    );\n\n    const items: string[] = [];\n\n    if (itemsInfo) for (const itemInfo of itemsInfo) items.push(itemInfo.item);\n\n    return items;\n  }\n\n  // public\n  querySegmentWithCoords(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    filter?: (other?: string) => boolean\n  ): {\n    item: string;\n    ti1: number;\n    ti2: number;\n    weight: number | null;\n    x1: number;\n    x2: number;\n    y1: number;\n    y2: number;\n  }[] {\n    let itemInfo: any = getInfoAboutItemsTouchedBySegment(\n      this,\n      x1,\n      y1,\n      x2,\n      y2,\n      filter\n    );\n\n    let dx: number = x2 - x1;\n    let dy: number = y2 - y1;\n\n    let info: any;\n    let ti1: number;\n    let ti2: number;\n\n    for (const item of itemInfo) {\n      info = item;\n\n      ti1 = info.ti1;\n      ti2 = info.ti2;\n\n      info.weight = null;\n      info.x1 = x1 + dx * ti1;\n      info.y1 = y1 + dy * ti1;\n      info.x2 = x1 + dx * ti2;\n      info.y2 = y1 + dy * ti2;\n    }\n\n    return itemInfo;\n  }\n\n\n  getItemByIndex(itemID: string): Object | undefined {\n    return this.reverseIdMap.get(itemID)\n  }\n\n\n\n\n  // public\n  add(item: Object, x: number, y: number, w: number, h: number): string {\n    if (!this.rectsMap.has(item)) {\n      this.rectsMap.set(item, (++this.currentIndex).toString());\n      // @ts-ignore\n      this.reverseIdMap.set(this.rectsMap.get(item), item)\n    } \n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      throw new Error(`Something went horribly wrong, an item was added but it's not in the map`);\n    }\n    const rect: IRect = this.rects[itemID];\n\n    if (rect) throw new Error(`Item \"${itemID}\" added to the world twice.`);\n\n    assertIsRect(x, y, w, h);\n\n    this.rects[itemID] = { x, y, w, h };\n\n    const [cl, ct, cw, ch] = grid_toCellRect(this.cellSize, x, y, w, h);\n\n    for (let cy = ct; cy < ct + ch; cy++)\n      for (let cx = cl; cx < cl + cw; cx++) this.addItemToCell(itemID, cx, cy);\n\n    return itemID;\n  }\n\n  // public\n  remove(item: Object): void {\n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      console.log(\"Trying to delete item that doesn't exist. Doing nothing\")\n      return\n    }\n    this._remove(itemID)\n    this.rectsMap.delete(item)\n    this.reverseIdMap.delete(itemID)\n  }\n  \n  _remove(itemID: string): void {\n\n    const itemRect: IRect = JSON.parse(JSON.stringify(this._getRect(itemID)));\n\n    delete this.rects[itemID];\n\n    let [cl, ct, cw, ch] = grid_toCellRect(\n      this.cellSize,\n      itemRect.x,\n      itemRect.y,\n      itemRect.w,\n      itemRect.h\n    );\n\n    for (let cy = ct; cy < ct + ch; cy++)\n      for (let cx = cl; cx < cl + cw; cx++)\n        this.removeItemFromCell(itemID, cx, cy);\n  }\n\n  // public\n  update(\n    itemID: string,\n    x2: number,\n    y2: number,\n    w2?: number,\n    h2?: number\n  ): void {\n    let itemRect = this._getRect(itemID);\n\n    w2 = isNaN(w2 as number) ? itemRect.w : w2;\n    h2 = isNaN(h2 as number) ? itemRect.h : h2;\n\n    assertIsRect(x2, y2, w2!, h2!);\n\n    if (\n      itemRect.x != x2 ||\n      itemRect.y != y2 ||\n      itemRect.w != w2 ||\n      itemRect.h != h2\n    ) {\n      const [cl1, ct1, cw1, ch1] = grid_toCellRect(\n        this.cellSize,\n        itemRect.x,\n        itemRect.y,\n        itemRect.w,\n        itemRect.h\n      );\n\n      const [cl2, ct2, cw2, ch2] = grid_toCellRect(\n        this.cellSize,\n        x2,\n        y2,\n        w2!,\n        h2!\n      );\n\n      if (cl1 != cl2 || ct1 != ct2 || cw1 != cw2 || ch1 != ch2) {\n        const cr1: number = cl1 + cw1 - 1;\n        const cb1: number = ct1 + ch1 - 1;\n\n        const cr2: number = cl2 + cw2 - 1;\n        const cb2: number = ct2 + ch2 - 1;\n\n        let cyOut: boolean;\n\n        for (let cy = ct1; cy <= cb1; cy++) {\n          cyOut = Number(cy) < ct2 || cy > cb2;\n\n          for (let cx = cl1; cx <= cr1; cx++)\n            if (cyOut || cx < cl2 || cx > cr2)\n              this.removeItemFromCell(itemID, cx, cy);\n        }\n\n        for (let cy = ct2; cy <= cb2; cy++) {\n          cyOut = cy < ct1 || cy > cb1;\n\n          for (let cx = cl2; cx <= cr2; cx++)\n            if (cyOut || cx < cl1 || cx > cr1)\n              this.addItemToCell(itemID, cx, cy);\n        }\n      }\n\n      const rect: IRect = this.rects[itemID];\n\n      rect.x = x2;\n      rect.y = y2;\n      rect.w = w2!;\n      rect.h = h2!;\n    }\n  }\n\n  // public\n  public move(\n    item: Object,\n    goalX: number,\n    goalY: number,\n    filter?: (...args: any[]) => any\n  ): { x: number; y: number; collisions: Collision[] }  {\n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      throw new Error(\"Trying to move item that doesn't exist.\");\n    }\n    return this._move(itemID, goalX, goalY, filter)\n  }\n\n  public _move(\n    itemID: string,\n    goalX: number,\n    goalY: number,\n    filter?: (...args: any[]) => any\n  ): { x: number; y: number; collisions: Collision[] } {\n    const { x, y, collisions } = this._check(itemID, goalX, goalY, filter);\n\n    this.update(itemID, x, y);\n\n    return { x, y, collisions };\n  }\n\n  // public\n  // TODO: make the function take objects\n\n  check(\n    item: Object,\n    goalX: number,\n    goalY: number,\n    filter?: (...args: any[]) => any\n  ): { x: number; y: number; collisions: Collision[] } {\n    const itemID = this.rectsMap.get(item)\n    if (itemID === undefined) {\n      throw new Error(\"Trying to check item that doesn't exist.\");\n    }\n    return this._check(itemID, goalX, goalY, filter)\n  }\n\n  _check(\n    itemID: string,\n    goalX: number,\n    goalY: number,\n    filter?: (...args: any[]) => any\n  ): { x: number; y: number; collisions: Collision[] } {\n    let _goalX: number = goalX;\n    let _goalY: number = goalY;\n\n    const checkFilter: any = filter || defaultFilter;\n\n    let visited: { [itemID: string]: boolean } = {};\n    visited[itemID] = true;\n\n    const visitedFilter = (itm: any, other: any) =>\n      !!visited[other] ? false : checkFilter(itm, other);\n\n    let detectedCollisions: Collision[] = [];\n\n    const itemRect: IRect = this._getRect(itemID);\n\n    // this is returning an empty array. WHY?\n    let projectedCollisions: Collision[] = this.project(\n      itemID,\n      itemRect.x,\n      itemRect.y,\n      itemRect.w,\n      itemRect.h,\n      _goalX,\n      _goalY,\n      visitedFilter\n    );\n\n    let collisionsCounter: number = projectedCollisions?.length || 0;\n\n    while (collisionsCounter > 0) {\n      const collision: Collision = projectedCollisions[0];\n\n      detectedCollisions.push(collision);\n\n      visited[collision.other] = true;\n\n      let response = this.getResponseByName(collision.type!);\n\n      const { x, y, collisions } = response(\n        this,\n        collision,\n        itemRect.x,\n        itemRect.y,\n        itemRect.w,\n        itemRect.h,\n        _goalX,\n        _goalY,\n        visitedFilter\n      );\n\n      _goalX = x;\n      _goalY = y;\n      projectedCollisions = collisions;\n\n      collisionsCounter = collisions?.length || 0;\n    }\n\n    return { x: _goalX, y: _goalY, collisions: detectedCollisions };\n  }\n}\n\n// Public library functions\n\nconst bump = {\n  newWorld: function(cellSize: number): World {\n    cellSize = cellSize || 64;\n\n    assertIsPositiveNumber(cellSize, 'cellSize');\n\n    const world: World = new World({\n      cellSize: cellSize,\n      rects: {},\n      rows: [],\n      nonEmptyCells: {},\n      responses: {},\n    });\n\n    world.addResponse('touch', touch);\n    world.addResponse('cross', cross);\n    world.addResponse('slide', slide);\n    world.addResponse('bounce', bounce);\n\n    return world;\n  },\n  rect: {\n    getNearestCorner: rect_getNearestCorner,\n    getSegmentIntersectionIndices: rect_getSegmentIntersectionIndices,\n    getDiff: rect_getDiff,\n    containsPoint: rect_containsPoint,\n    isIntersecting: rect_isIntersecting,\n    getSquareDistance: rect_getSquareDistance,\n    detectCollision: rect_detectCollision,\n  },\n  responses: {\n    touch,\n    cross,\n    slide,\n    bounce,\n  },\n};\n\nexport default Object.freeze(bump);\n","export default function assertIsPositiveNumber(\n  value: number,\n  name: string\n): void {\n  if (isNaN(value) || value <= 0)\n    throw new Error(\n      `\"${name}\" must be a positive integer, but was ${value} (${typeof value})`\n    );\n}\n","import { Collision, ICoords, IRect } from '.';\nimport { DELTA } from './constants';\nimport nearest from './helpers/generic/nearest';\n\nexport function rect_getNearestCorner(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  px: number,\n  py: number\n): ICoords {\n  return { x: nearest(px, x, x + w), y: nearest(py, y, y + h) };\n}\n\n// This is a generalized implementation of the liang-barsky algorithm, which also returns\n// the normals of the sides where the segment intersects.\n// Returns null if the segment never touches the rect\n// Notice that normals are only guaranteed to be accurate when initially ti1, ti2 == -math.huge, math.huge\nexport function rect_getSegmentIntersectionIndices(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  ti1: number,\n  ti2: number\n): [number?, number?, number?, number?, number?, number?] {\n  let _ti1 = isNaN(ti1) ? 0 : ti1;\n  let _ti2 = isNaN(ti2) ? 1 : ti2;\n\n  let dx: number = x2 - x1;\n  let dy: number = y2 - y1;\n  let nx: number;\n  let ny: number;\n  let nx1: number = 0;\n  let ny1: number = 0;\n  let nx2: number = 0;\n  let ny2: number = 0;\n  let p, q, r;\n\n  for (const side of [1, 2, 3, 4]) {\n    // left\n    if (side === 1) {\n      nx = -1;\n      ny = 0;\n      p = -dx;\n      q = x1 - x;\n    }\n    // right\n    else if (side === 2) {\n      nx = 1;\n      ny = 0;\n      p = dx;\n      q = x + w - x1;\n    }\n    // top\n    else if (side === 3) {\n      nx = 0;\n      ny = -1;\n      p = -dy;\n      q = y1 - y;\n    }\n    // bottom\n    else {\n      nx = 0;\n      ny = 1;\n      p = dy;\n      q = y + h - y1;\n    }\n\n    if (p === 0) {\n      if (q <= 0)\n        return [\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n        ];\n    } else {\n      r = q / p;\n\n      if (p < 0) {\n        if (r > _ti2)\n          return [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n          ];\n        else if (r > _ti1) {\n          _ti1 = r;\n          nx1 = nx;\n          ny1 = ny;\n        }\n      } // p > 0\n      else {\n        if (r < _ti1)\n          return [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n          ];\n        else if (r < _ti2) {\n          _ti2 = r;\n          nx2 = nx;\n          ny2 = ny;\n        }\n      }\n    }\n  }\n\n  return [_ti1, _ti2, nx1, ny1, nx2, ny2];\n}\n\n// //Calculates the Minkowsky difference between 2 rects, which is another rect\nexport function rect_getDiff(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number\n): IRect {\n  return {\n    x: x2 - x1 - w1,\n    y: y2 - y1 - h1,\n    w: w1 + w2,\n    h: h1 + h2,\n  };\n}\n\nexport function rect_containsPoint(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  px: number,\n  py: number\n): boolean {\n  return (\n    px - x > DELTA && py - y > DELTA && x + w - px > DELTA && y + h - py > DELTA\n  );\n}\n\nexport function rect_isIntersecting(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number\n): boolean {\n  return x1 < x2 + w2 && x2 < x1 + w1 && y1 < y2 + h2 && y2 < y1 + h1;\n}\n\nexport function rect_getSquareDistance(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number\n): number {\n  const dx = x1 - x2 + (w1 - w2) / 2;\n  const dy = y1 - y2 + (h1 - h2) / 2;\n  return dx * dx + dy * dy;\n}\n\nexport function rect_detectCollision(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number,\n  goalX?: number,\n  goalY?: number\n): undefined | Partial<Collision> {\n  const _goalX: number = isNaN(goalX!) ? x1 : goalX!;\n  const _goalY: number = isNaN(goalY!) ? y1 : goalY!;\n\n  let dx: number = _goalX - x1;\n  let dy: number = _goalY - y1;\n\n  const { x, y, w, h } = rect_getDiff(x1, y1, w1, h1, x2, y2, w2, h2);\n\n  let overlaps: boolean;\n\n  let nx, ny;\n  let ti: number;\n\n  // If the item was intersecting other\n  if (rect_containsPoint(x, y, w, h, 0, 0)) {\n    let { x: px, y: py } = rect_getNearestCorner(x, y, w, h, 0, 0);\n\n    let wi: number = Math.min(w1, Math.abs(px)); // area of intersection\n    let hi: number = Math.min(h1, Math.abs(py)); // area of intersection\n\n    ti = -wi * hi; // `ti` is the negative area of intersection\n\n    overlaps = true;\n  } else {\n    let [ti1, ti2, nx1, ny1] = rect_getSegmentIntersectionIndices(\n      x,\n      y,\n      w,\n      h,\n      0,\n      0,\n      dx,\n      dy,\n      -Number.MAX_SAFE_INTEGER,\n      Number.MAX_SAFE_INTEGER\n    );\n\n    // To make the compiler stop complaining\n    ti1 = ti1!;\n\n    // item tunnels into other\n    if (\n      !isNaN(ti1) &&\n      ti1 < 1 &&\n      Math.abs(ti1 - (ti2 || 0)) >= DELTA && // special case for rect going through another rect's corner\n      (0 < ti1 + DELTA || (0 === ti1 && (ti2 || 0) > 0))\n    ) {\n      ti = ti1;\n      nx = nx1;\n      ny = ny1;\n\n      overlaps = false;\n    }\n  }\n\n  if (isNaN(ti!)) return;\n\n  let tx, ty;\n\n  if (overlaps!)\n    if (dx === 0 && dy === 0) {\n      //intersecting and not moving - use minimum displacement vector\n      let { x: px, y: py } = rect_getNearestCorner(x, y, w, h, 0, 0);\n\n      if (Math.abs(px) < Math.abs(py)) py = 0;\n      else px = 0;\n\n      nx = Math.sign(px);\n      ny = Math.sign(py);\n\n      tx = x1 + px;\n      ty = y1 + py;\n    } else {\n      //intersecting and moving - move in the opposite direction\n      // @ts-ignore\n      let [ti1, _, _nx, _ny] = rect_getSegmentIntersectionIndices(\n        x,\n        y,\n        w,\n        h,\n        0,\n        0,\n        dx,\n        dy,\n        -Number.MAX_SAFE_INTEGER,\n        1\n      );\n      nx = _nx;\n      ny = _ny;\n\n      if (!ti1) return;\n\n      tx = x1 + dx * ti1;\n      ty = y1 + dy * ti1;\n    }\n  //tunnel\n  else {\n    // @ts-ignore\n    tx = x1 + dx * ti;\n    // @ts-ignore\n    ty = y1 + dy * ti;\n  }\n\n  return {\n    overlaps: overlaps!,\n    // @ts-ignore\n    ti,\n    move: { x: dx, y: dy },\n    normal: { x: nx as number, y: ny as number },\n    touch: { x: tx, y: ty },\n    itemRect: { x: x1, y: y1, w: w1, h: h1 },\n    otherRect: { x: x2, y: y2, w: w2, h: h2 },\n  };\n}\n","export const DELTA = 1e-10; // floating-point margin of error\n","export default function nearest(x: number, a: number, b: number): number {\n  return Math.abs(a - x) < Math.abs(b - x) ? a : b;\n}\n","export function grid_toWorld(\n  cellSize: number,\n  cx: number,\n  cy: number\n): [number, number] {\n  return [(cx - 1) * cellSize, (cy - 1) * cellSize];\n}\n\nexport function grid_toCell(\n  cellSize: number,\n  x: number,\n  y: number\n): [number, number] {\n  return [Math.floor(x / cellSize) + 1, Math.floor(y / cellSize) + 1];\n}\n\n//grid_traverse * functions are based on \"A Fast Voxel Traversal Algorithm for Ray Tracing\",\n//by John Amanides and Andrew Woo - http://www.cse.yorku.ca/~amana/research/grid.pdf\n//It has been modified to include both cells when the ray \"touches a grid corner\",\n//and with a different exit condition\n\nexport function grid_traverse_initStep(\n  cellSize: number,\n  ct: number,\n  t1: number,\n  t2: number\n): [number, number, number] {\n  const v: number = t2 - t1;\n\n  if (v > 0) return [1, cellSize / v, ((ct + v) * cellSize - t1) / v];\n  else if (v < 0)\n    return [-1, -cellSize / v, ((ct + v - 1) * cellSize - t1) / v];\n  else return [0, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER];\n}\n\nexport function grid_traverse(\n  cellSize: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  traverseFunction: (cx: number, cy: number) => void\n): void {\n  const [cx1, cy1] = grid_toCell(cellSize, x1, y1);\n  const [cx2, cy2] = grid_toCell(cellSize, x2, y2);\n  let [stepX, dx, tx] = grid_traverse_initStep(cellSize, cx1, x1, x2);\n  let [stepY, dy, ty] = grid_traverse_initStep(cellSize, cy1, y1, y2);\n  let [cx, cy] = [cx1, cy1];\n\n  traverseFunction(cx, cy);\n\n  // The default implementation had an infinite loop problem when\n  // approaching the last cell in some occassions. We finish iterating\n  // when we are *next* to the last cell.\n  do {\n    if (tx < ty) {\n      [tx, cx] = [tx + dx, cx + stepX];\n\n      traverseFunction(cx, cy);\n    } else {\n      // Addition: include both cells when going through corners\n      if (tx == ty) traverseFunction(cx + stepX, cy);\n\n      ty = ty + dy;\n      cy = cy + stepY;\n\n      traverseFunction(cx, cy);\n    }\n  } while (Math.abs(cx - cx2) + Math.abs(cy - cy2) > 1);\n\n  //If we have not arrived to the last cell, use it\n  if (cx != cx2 || cy != cy2) traverseFunction(cx2, cy2);\n}\n\nexport function grid_toCellRect(\n  cellSize: number,\n  x: number,\n  y: number,\n  w: number,\n  h: number\n): [number, number, number, number] {\n  let [cx, cy] = grid_toCell(cellSize, x, y);\n\n  const cr: number = Math.ceil((x + w) / cellSize);\n  const cb: number = Math.ceil((y + h) / cellSize);\n\n  return [cx, cy, cr - cx + 1, cb - cy + 1];\n}\n","import assertIsPositiveNumber from './assertIsPositiveNumber';\nimport assertType from './assertType';\n\nexport default function assertIsRect(\n  x: number,\n  y: number,\n  w: number,\n  h: number\n): void {\n  assertType('number', x, 'x');\n  assertType('number', y, 'y');\n  assertIsPositiveNumber(w, 'w');\n  assertIsPositiveNumber(h, 'h');\n}\n","export default function assertType(desiredType: string, value: any, name: string): void {\n  if (typeof value !== desiredType)\n    throw new Error(\n      `\"${name}\" must be a ${desiredType}, but was a ${value} (${typeof value})`\n    );\n}\n","import { Collision, ICoords, World } from '../../index';\n\nexport type Response = (\n  world: World,\n  col: any,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  goalX: number,\n  goalY: number,\n  filter: any\n) => { x: number; y: number; collisions: Collision[] };\n\nexport function touch(\n  _world: World,\n  column: {\n    touch: ICoords;\n    move: ICoords;\n    normal: ICoords;\n    slide: ICoords;\n    item: any;\n  },\n  _x: number,\n  _y: number,\n  _w: number,\n  _h: number,\n  _goalX: number,\n  _goalY: number,\n  _filter: any\n): { x: number; y: number; collisions: Collision[] } {\n  return { x: column.touch.x, y: column.touch.y, collisions: [] };\n}\n\nexport function cross(\n  world: any,\n  column: {\n    touch: ICoords;\n    move: ICoords;\n    normal: ICoords;\n    slide: ICoords;\n    item: any;\n  },\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  goalX: number,\n  goalY: number,\n  filter: any\n): { x: number; y: number; collisions: Collision[] } {\n  const collisions = world.project(\n    column.item,\n    x,\n    y,\n    w,\n    h,\n    goalX,\n    goalY,\n    filter\n  );\n\n  return { x: goalX, y: goalY, collisions };\n}\n\nexport function slide(\n  world: World,\n  column: {\n    touch: ICoords;\n    move: ICoords;\n    normal: ICoords;\n    slide: ICoords;\n    item: any;\n  },\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  goalX: number,\n  goalY: number,\n  filter?: any\n): { x: number; y: number; collisions: Collision[] } {\n  let _goalX: number = isNaN(goalX) ? x : goalX;\n  let _goalY: number = isNaN(goalY) ? y : goalY;\n\n  const tch: ICoords = column.touch;\n  const move: ICoords = column.move;\n\n  if (move.x !== 0 || move.y !== 0)\n    if (column.normal.x !== 0) _goalX = tch.x;\n    else _goalY = tch.y;\n\n  column.slide = { x: _goalX, y: _goalY };\n\n  const _x: number = tch.x;\n  const _y: number = tch.y;\n\n  const collisions = world.project(\n    column.item,\n    _x,\n    _y,\n    w,\n    h,\n    _goalX,\n    _goalY,\n    filter\n  );\n\n  return { x: _goalX, y: _goalY, collisions };\n}\n\nexport function bounce(\n  world: World,\n  collision: any,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  goalX?: number,\n  goalY?: number,\n  filter?: any\n): { x: number; y: number; collisions: Collision[] } {\n  const _goalX: number = isNaN(goalX as number) ? x : goalX!;\n  const _goalY: number = isNaN(goalY as number) ? y : goalY!;\n\n  const { touch, move } = collision;\n\n  let bx = touch.x;\n  let by = touch.y;\n\n  if (move.x !== 0 || move.y !== 0) {\n    let bnx = _goalX - touch.x;\n    let bny = _goalY - touch.y;\n\n    if (collision.normal.x === 0) bny = -bny;\n    else bnx = -bnx;\n\n    bx = touch.x + bnx;\n    by = touch.y + bny;\n  }\n\n  collision.bounce = { x: bx, y: by };\n\n  const collisions = world.project(\n    collision.item,\n    touch.x,\n    touch.y,\n    w,\n    h,\n    bx,\n    by,\n    filter\n  );\n\n  return { x: bx, y: by, collisions };\n}\n","import { IRect } from '../..';\nimport { rect_getSquareDistance } from '../../rect';\n\ninterface Item {\n  // x: number;\n  // y: number;\n  // w: number;\n  // h: number;\n  ti: number;\n  itemRect: IRect;\n  otherRect: IRect;\n}\n\nexport default function sortByTiAndDistance(a: Item, b: Item): number {\n  if (a.ti === b.ti) {\n    const ir: IRect = a.itemRect;\n    const ar: IRect = a.otherRect;\n    const br: IRect = b.otherRect;\n\n    const ad = rect_getSquareDistance(\n      ir.x,\n      ir.y,\n      ir.w,\n      ir.h,\n      ar.x,\n      ar.y,\n      ar.w,\n      ar.h\n    );\n    const bd = rect_getSquareDistance(\n      ir.x,\n      ir.y,\n      ir.w,\n      ir.h,\n      br.x,\n      br.y,\n      br.w,\n      br.h\n    );\n\n    return ad - bd;\n  }\n\n  return a.ti - b.ti;\n}\n"],"names":[],"version":3,"file":"bump-kaboom.js.map"}